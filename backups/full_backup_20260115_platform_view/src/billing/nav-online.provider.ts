import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import * as crypto from 'crypto';
import {
  InvoiceProvider,
  CreateInvoiceRequest,
  CreateInvoiceResponse,
  CancelInvoiceRequest,
  CancelInvoiceResponse,
  GetInvoicePdfRequest,
  GetInvoicePdfResponse,
} from './invoice-provider.interface';

/**
 * NAV Online Számla API v3.0 invoice provider implementation
 *
 * This provider implements the Hungarian Tax Authority's (NAV) online invoice
 * reporting system. It allows sending invoice data to NAV for tax compliance.
 *
 * API Documentation: https://onlineszamla.nav.gov.hu/api/files/container/download/Online%20Szamla%20Rendszer%20Interfesz%20specifikacio%20HU.pdf
 *
 * IMPORTANT: This is for REPORTING invoices to NAV, not for generating PDFs.
 * The actual invoice should be generated by another provider (Billingo, Számlázz.hu)
 * and then reported to NAV.
 */
@Injectable()
export class NavOnlineProvider extends InvoiceProvider {
  private readonly logger = new Logger(NavOnlineProvider.name);
  readonly providerName = 'nav_online';

  // NAV API endpoints
  private readonly apiUrls = {
    test: 'https://api-test.onlineszamla.nav.gov.hu/invoiceService/v3',
    production: 'https://api.onlineszamla.nav.gov.hu/invoiceService/v3',
  };

  // Configuration - can be set per-network
  private technicalUser: string;
  private technicalPassword: string; // Plain password
  private taxNumber: string;
  private signatureKey: string;
  private exchangeKey: string;
  private isProduction: boolean;

  constructor(private configService: ConfigService) {
    super();
    // Default values from env (can be overridden per network)
    this.technicalUser = this.configService.get<string>('NAV_ONLINE_USER', '');
    this.technicalPassword = this.configService.get<string>('NAV_ONLINE_PASSWORD', '');
    this.taxNumber = this.configService.get<string>('NAV_ONLINE_TAX_NUM', '');
    this.signatureKey = this.configService.get<string>('NAV_ONLINE_SIGN_KEY', '');
    this.exchangeKey = this.configService.get<string>('NAV_ONLINE_EXCH_KEY', '');
    this.isProduction = this.configService.get<string>('NAV_ONLINE_ENV', 'test') === 'production';
  }

  /**
   * Configure the provider with network-specific settings
   */
  configure(
    user: string,
    password: string,
    taxNumber: string,
    signatureKey: string,
    exchangeKey: string,
    isProduction: boolean = false,
  ): void {
    this.technicalUser = user;
    this.technicalPassword = password;
    this.taxNumber = taxNumber;
    this.signatureKey = signatureKey;
    this.exchangeKey = exchangeKey;
    this.isProduction = isProduction;
  }

  /**
   * Create and report an invoice to NAV
   *
   * Note: NAV Online Számla doesn't generate invoices - it only reports them.
   * The invoice XML must be created according to NAV's XSD schema.
   */
  async createInvoice(request: CreateInvoiceRequest): Promise<CreateInvoiceResponse> {
    try {
      if (!this.technicalUser || !this.signatureKey) {
        throw new Error('NAV Online Számla credentials not configured');
      }

      // Generate request ID and timestamp
      const requestId = this.generateRequestId();
      const timestamp = new Date().toISOString().replace(/\.\d{3}Z$/, 'Z');

      // Create invoice XML according to NAV schema
      const invoiceXml = this.createInvoiceXml(request);

      // Encode invoice data
      const invoiceData = Buffer.from(invoiceXml).toString('base64');

      // Calculate invoice hash
      const invoiceHash = crypto
        .createHash('sha3-512')
        .update(invoiceXml)
        .digest('hex')
        .toUpperCase();

      // Create the request signature
      const requestSignature = this.calculateRequestSignature(
        requestId,
        timestamp,
        this.signatureKey,
      );

      // Build the SOAP request
      const soapRequest = this.buildManageInvoiceRequest(
        requestId,
        timestamp,
        requestSignature,
        invoiceData,
        invoiceHash,
      );

      this.logger.debug('Sending invoice to NAV', { requestId });

      // Send to NAV
      const apiUrl = this.isProduction ? this.apiUrls.production : this.apiUrls.test;
      const response = await fetch(`${apiUrl}/manageInvoice`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/xml',
          'Accept': 'application/xml',
        },
        body: soapRequest,
      });

      const responseText = await response.text();

      if (!response.ok) {
        this.logger.error('NAV API error', { status: response.status, response: responseText });
        return {
          success: false,
          error: `NAV API error: ${response.status}`,
          rawResponse: responseText,
        };
      }

      // Parse response
      const transactionId = this.extractTransactionId(responseText);

      if (transactionId) {
        return {
          success: true,
          externalId: transactionId,
          rawResponse: responseText,
        };
      } else {
        const errorMessage = this.extractErrorMessage(responseText);
        return {
          success: false,
          error: errorMessage || 'Unknown NAV error',
          rawResponse: responseText,
        };
      }
    } catch (error: any) {
      this.logger.error('Error reporting invoice to NAV', error);
      return {
        success: false,
        error: error.message || 'Unknown error reporting to NAV',
      };
    }
  }

  /**
   * Cancel/storno an invoice in NAV
   */
  async cancelInvoice(request: CancelInvoiceRequest): Promise<CancelInvoiceResponse> {
    try {
      if (!this.technicalUser || !this.signatureKey) {
        throw new Error('NAV Online Számla credentials not configured');
      }

      // Generate request ID and timestamp
      const requestId = this.generateRequestId();
      const timestamp = new Date().toISOString().replace(/\.\d{3}Z$/, 'Z');

      // Create storno invoice XML
      const stornoXml = this.createStornoInvoiceXml(request.invoiceNumber, request.reason);

      // Encode invoice data
      const invoiceData = Buffer.from(stornoXml).toString('base64');

      // Calculate invoice hash
      const invoiceHash = crypto
        .createHash('sha3-512')
        .update(stornoXml)
        .digest('hex')
        .toUpperCase();

      // Create the request signature
      const requestSignature = this.calculateRequestSignature(
        requestId,
        timestamp,
        this.signatureKey,
      );

      // Build the SOAP request
      const soapRequest = this.buildManageInvoiceRequest(
        requestId,
        timestamp,
        requestSignature,
        invoiceData,
        invoiceHash,
        'STORNO',
      );

      this.logger.debug('Sending storno to NAV', { requestId, invoiceNumber: request.invoiceNumber });

      // Send to NAV
      const apiUrl = this.isProduction ? this.apiUrls.production : this.apiUrls.test;
      const response = await fetch(`${apiUrl}/manageInvoice`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/xml',
          'Accept': 'application/xml',
        },
        body: soapRequest,
      });

      const responseText = await response.text();

      if (!response.ok) {
        return {
          success: false,
          error: `NAV API error: ${response.status}`,
        };
      }

      const transactionId = this.extractTransactionId(responseText);

      if (transactionId) {
        return {
          success: true,
          cancelledInvoiceNumber: request.invoiceNumber,
        };
      } else {
        return {
          success: false,
          error: this.extractErrorMessage(responseText) || 'Unknown NAV error',
        };
      }
    } catch (error: any) {
      this.logger.error('Error cancelling invoice in NAV', error);
      return {
        success: false,
        error: error.message || 'Unknown error',
      };
    }
  }

  /**
   * NAV doesn't provide PDFs - this returns an error
   */
  async getInvoicePdf(_request: GetInvoicePdfRequest): Promise<GetInvoicePdfResponse> {
    return {
      success: false,
      error: 'NAV Online Számla does not provide invoice PDFs. Use Billingo or Számlázz.hu for PDF generation.',
    };
  }

  /**
   * Validate connection to NAV
   */
  async validateConnection(): Promise<boolean> {
    try {
      if (!this.technicalUser || !this.signatureKey) {
        return false;
      }

      // Try to query taxpayer
      const requestId = this.generateRequestId();
      const timestamp = new Date().toISOString().replace(/\.\d{3}Z$/, 'Z');
      const requestSignature = this.calculateRequestSignature(
        requestId,
        timestamp,
        this.signatureKey,
      );

      const queryRequest = this.buildQueryTaxpayerRequest(
        requestId,
        timestamp,
        requestSignature,
        this.taxNumber,
      );

      const apiUrl = this.isProduction ? this.apiUrls.production : this.apiUrls.test;
      const response = await fetch(`${apiUrl}/queryTaxpayer`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/xml',
          'Accept': 'application/xml',
        },
        body: queryRequest,
      });

      return response.ok;
    } catch (error) {
      this.logger.error('NAV connection validation failed', error);
      return false;
    }
  }

  /**
   * Query invoice status from NAV
   */
  async queryInvoiceStatus(transactionId: string): Promise<{
    success: boolean;
    status?: string;
    error?: string;
  }> {
    try {
      const requestId = this.generateRequestId();
      const timestamp = new Date().toISOString().replace(/\.\d{3}Z$/, 'Z');
      const requestSignature = this.calculateRequestSignature(
        requestId,
        timestamp,
        this.signatureKey,
      );

      const queryRequest = this.buildQueryTransactionStatusRequest(
        requestId,
        timestamp,
        requestSignature,
        transactionId,
      );

      const apiUrl = this.isProduction ? this.apiUrls.production : this.apiUrls.test;
      const response = await fetch(`${apiUrl}/queryTransactionStatus`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/xml',
          'Accept': 'application/xml',
        },
        body: queryRequest,
      });

      const responseText = await response.text();

      if (!response.ok) {
        return {
          success: false,
          error: `NAV API error: ${response.status}`,
        };
      }

      // Extract status from response
      const statusMatch = responseText.match(/<invoiceStatus>(\w+)<\/invoiceStatus>/);
      return {
        success: true,
        status: statusMatch ? statusMatch[1] : 'UNKNOWN',
      };
    } catch (error: any) {
      return {
        success: false,
        error: error.message,
      };
    }
  }

  // =========================================================================
  // PRIVATE HELPERS
  // =========================================================================

  /**
   * Generate unique request ID
   */
  private generateRequestId(): string {
    const prefix = 'VSY';
    const timestamp = Date.now().toString(36).toUpperCase();
    const random = crypto.randomBytes(8).toString('hex').toUpperCase().substring(0, 10);
    return `${prefix}${timestamp}${random}`.substring(0, 30);
  }

  /**
   * Calculate request signature according to NAV specification
   * signature = SHA3-512(requestId + timestamp + signatureKey)
   */
  private calculateRequestSignature(
    requestId: string,
    timestamp: string,
    signatureKey: string,
  ): string {
    // Timestamp must be in format: yyyyMMddHHmmss
    const formattedTimestamp = timestamp
      .replace(/[-:TZ]/g, '')
      .substring(0, 14);

    const dataToSign = requestId + formattedTimestamp + signatureKey;

    return crypto
      .createHash('sha3-512')
      .update(dataToSign)
      .digest('hex')
      .toUpperCase();
  }

  /**
   * Hash the technical user's password
   * passwordHash = SHA-512(password)
   */
  private hashPassword(password: string): string {
    return crypto
      .createHash('sha512')
      .update(password)
      .digest('hex')
      .toUpperCase();
  }

  /**
   * Create invoice XML according to NAV schema (simplified version)
   * Full implementation would need complete XSD schema compliance
   */
  private createInvoiceXml(request: CreateInvoiceRequest): string {
    const now = new Date();
    const invoiceDate = now.toISOString().split('T')[0];
    const dueDate = new Date(now.getTime() + request.paymentDueDays * 24 * 60 * 60 * 1000)
      .toISOString()
      .split('T')[0];

    // Calculate totals
    let netAmount = 0;
    let vatAmount = 0;
    const itemsXml = request.items.map((item, index) => {
      const lineNet = item.quantity * item.unitPrice;
      const lineVat = lineNet * (item.vatRate / 100);
      netAmount += lineNet;
      vatAmount += lineVat;

      return `
        <line>
          <lineNumber>${index + 1}</lineNumber>
          <lineDescription>${this.escapeXml(item.description)}</lineDescription>
          <quantity>${item.quantity}</quantity>
          <unitOfMeasure>${item.unit || 'PIECE'}</unitOfMeasure>
          <unitPrice>${item.unitPrice.toFixed(2)}</unitPrice>
          <lineNetAmount>${lineNet.toFixed(2)}</lineNetAmount>
          <lineVatRate>
            <vatPercentage>${item.vatRate}</vatPercentage>
          </lineVatRate>
          <lineVatData>
            <lineVatAmount>${lineVat.toFixed(2)}</lineVatAmount>
          </lineVatData>
          <lineGrossAmountData>
            <lineGrossAmountNormal>${(lineNet + lineVat).toFixed(2)}</lineGrossAmountNormal>
          </lineGrossAmountData>
        </line>`;
    }).join('');

    const grossAmount = netAmount + vatAmount;

    // Payment method mapping
    const paymentMethodMap: Record<string, string> = {
      cash: 'CASH',
      transfer: 'TRANSFER',
      card: 'CARD',
      other: 'OTHER',
    };

    return `<?xml version="1.0" encoding="UTF-8"?>
<InvoiceData xmlns="http://schemas.nav.gov.hu/OSA/3.0/data" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <invoiceNumber>AUTO</invoiceNumber>
  <invoiceIssueDate>${invoiceDate}</invoiceIssueDate>
  <completenessIndicator>false</completenessIndicator>
  <invoiceMain>
    <invoice>
      <invoiceHead>
        <supplierInfo>
          <supplierTaxNumber>
            <taxpayerId>${this.taxNumber.substring(0, 8)}</taxpayerId>
            <vatCode>${this.taxNumber.substring(8, 9) || '2'}</vatCode>
            <countyCode>${this.taxNumber.substring(9, 11) || '02'}</countyCode>
          </supplierTaxNumber>
          <supplierName>${this.escapeXml(request.customer.name)}</supplierName>
          <supplierAddress>
            <simpleAddress>
              <countryCode>${request.customer.country || 'HU'}</countryCode>
              <postalCode>${request.customer.zipCode}</postalCode>
              <city>${this.escapeXml(request.customer.city)}</city>
              <additionalAddressDetail>${this.escapeXml(request.customer.address)}</additionalAddressDetail>
            </simpleAddress>
          </supplierAddress>
        </supplierInfo>
        <customerInfo>
          <customerVatStatus>DOMESTIC</customerVatStatus>
          ${request.customer.taxNumber ? `
          <customerVatData>
            <customerTaxNumber>
              <taxpayerId>${request.customer.taxNumber.substring(0, 8)}</taxpayerId>
              <vatCode>${request.customer.taxNumber.substring(8, 9) || '2'}</vatCode>
              <countyCode>${request.customer.taxNumber.substring(9, 11) || '02'}</countyCode>
            </customerTaxNumber>
          </customerVatData>` : ''}
          <customerName>${this.escapeXml(request.customer.name)}</customerName>
          <customerAddress>
            <simpleAddress>
              <countryCode>${request.customer.country || 'HU'}</countryCode>
              <postalCode>${request.customer.zipCode}</postalCode>
              <city>${this.escapeXml(request.customer.city)}</city>
              <additionalAddressDetail>${this.escapeXml(request.customer.address)}</additionalAddressDetail>
            </simpleAddress>
          </customerAddress>
        </customerInfo>
        <invoiceDetail>
          <invoiceCategory>NORMAL</invoiceCategory>
          <invoiceDeliveryDate>${invoiceDate}</invoiceDeliveryDate>
          <currencyCode>${request.currency || 'HUF'}</currencyCode>
          <exchangeRate>1</exchangeRate>
          <paymentMethod>${paymentMethodMap[request.paymentMethod] || 'TRANSFER'}</paymentMethod>
          <paymentDate>${dueDate}</paymentDate>
          <invoiceAppearance>ELECTRONIC</invoiceAppearance>
        </invoiceDetail>
      </invoiceHead>
      <invoiceLines>
        ${itemsXml}
      </invoiceLines>
      <invoiceSummary>
        <summaryNormal>
          <summaryByVatRate>
            <vatRate>
              <vatPercentage>27</vatPercentage>
            </vatRate>
            <vatRateNetData>
              <vatRateNetAmount>${netAmount.toFixed(2)}</vatRateNetAmount>
            </vatRateNetData>
            <vatRateVatData>
              <vatRateVatAmount>${vatAmount.toFixed(2)}</vatRateVatAmount>
            </vatRateVatData>
          </summaryByVatRate>
          <invoiceNetAmount>${netAmount.toFixed(2)}</invoiceNetAmount>
          <invoiceVatAmount>${vatAmount.toFixed(2)}</invoiceVatAmount>
        </summaryNormal>
        <summaryGrossData>
          <invoiceGrossAmount>${grossAmount.toFixed(2)}</invoiceGrossAmount>
        </summaryGrossData>
      </invoiceSummary>
    </invoice>
  </invoiceMain>
</InvoiceData>`;
  }

  /**
   * Create storno invoice XML
   */
  private createStornoInvoiceXml(originalInvoiceNumber: string, reason?: string): string {
    const now = new Date();
    const invoiceDate = now.toISOString().split('T')[0];

    return `<?xml version="1.0" encoding="UTF-8"?>
<InvoiceData xmlns="http://schemas.nav.gov.hu/OSA/3.0/data">
  <invoiceNumber>STORNO-${originalInvoiceNumber}</invoiceNumber>
  <invoiceIssueDate>${invoiceDate}</invoiceIssueDate>
  <completenessIndicator>true</completenessIndicator>
  <invoiceMain>
    <invoice>
      <invoiceReference>
        <originalInvoiceNumber>${originalInvoiceNumber}</originalInvoiceNumber>
        <modifyWithoutMaster>true</modifyWithoutMaster>
        <modificationIndex>1</modificationIndex>
      </invoiceReference>
    </invoice>
  </invoiceMain>
</InvoiceData>`;
  }

  /**
   * Build ManageInvoice SOAP request
   */
  private buildManageInvoiceRequest(
    requestId: string,
    timestamp: string,
    requestSignature: string,
    invoiceData: string,
    invoiceHash: string,
    operation: string = 'CREATE',
  ): string {
    const passwordHash = this.hashPassword(this.technicalPassword);

    return `<?xml version="1.0" encoding="UTF-8"?>
<ManageInvoiceRequest xmlns="http://schemas.nav.gov.hu/OSA/3.0/api">
  <header>
    <requestId>${requestId}</requestId>
    <timestamp>${timestamp}</timestamp>
    <requestVersion>3.0</requestVersion>
    <headerVersion>1.0</headerVersion>
  </header>
  <user>
    <login>${this.technicalUser}</login>
    <passwordHash cryptoType="SHA-512">${passwordHash}</passwordHash>
    <taxNumber>${this.taxNumber}</taxNumber>
    <requestSignature cryptoType="SHA3-512">${requestSignature}</requestSignature>
  </user>
  <software>
    <softwareId>VSYSWASH001-001</softwareId>
    <softwareName>vSys Wash</softwareName>
    <softwareOperation>LOCAL_SOFTWARE</softwareOperation>
    <softwareMainVersion>1.0</softwareMainVersion>
    <softwareDevName>vSys</softwareDevName>
    <softwareDevContact>info@vsys.hu</softwareDevContact>
  </software>
  <exchangeToken>${this.exchangeKey}</exchangeToken>
  <invoiceOperations>
    <compressedContent>false</compressedContent>
    <invoiceOperation>
      <index>1</index>
      <invoiceOperation>${operation}</invoiceOperation>
      <invoiceData>${invoiceData}</invoiceData>
    </invoiceOperation>
  </invoiceOperations>
</ManageInvoiceRequest>`;
  }

  /**
   * Build QueryTaxpayer request
   */
  private buildQueryTaxpayerRequest(
    requestId: string,
    timestamp: string,
    requestSignature: string,
    taxNumber: string,
  ): string {
    const passwordHash = this.hashPassword(this.technicalPassword);

    return `<?xml version="1.0" encoding="UTF-8"?>
<QueryTaxpayerRequest xmlns="http://schemas.nav.gov.hu/OSA/3.0/api">
  <header>
    <requestId>${requestId}</requestId>
    <timestamp>${timestamp}</timestamp>
    <requestVersion>3.0</requestVersion>
    <headerVersion>1.0</headerVersion>
  </header>
  <user>
    <login>${this.technicalUser}</login>
    <passwordHash cryptoType="SHA-512">${passwordHash}</passwordHash>
    <taxNumber>${this.taxNumber}</taxNumber>
    <requestSignature cryptoType="SHA3-512">${requestSignature}</requestSignature>
  </user>
  <software>
    <softwareId>VSYSWASH001-001</softwareId>
    <softwareName>vSys Wash</softwareName>
    <softwareOperation>LOCAL_SOFTWARE</softwareOperation>
    <softwareMainVersion>1.0</softwareMainVersion>
    <softwareDevName>vSys</softwareDevName>
    <softwareDevContact>info@vsys.hu</softwareDevContact>
  </software>
  <taxNumber>${taxNumber}</taxNumber>
</QueryTaxpayerRequest>`;
  }

  /**
   * Build QueryTransactionStatus request
   */
  private buildQueryTransactionStatusRequest(
    requestId: string,
    timestamp: string,
    requestSignature: string,
    transactionId: string,
  ): string {
    const passwordHash = this.hashPassword(this.technicalPassword);

    return `<?xml version="1.0" encoding="UTF-8"?>
<QueryTransactionStatusRequest xmlns="http://schemas.nav.gov.hu/OSA/3.0/api">
  <header>
    <requestId>${requestId}</requestId>
    <timestamp>${timestamp}</timestamp>
    <requestVersion>3.0</requestVersion>
    <headerVersion>1.0</headerVersion>
  </header>
  <user>
    <login>${this.technicalUser}</login>
    <passwordHash cryptoType="SHA-512">${passwordHash}</passwordHash>
    <taxNumber>${this.taxNumber}</taxNumber>
    <requestSignature cryptoType="SHA3-512">${requestSignature}</requestSignature>
  </user>
  <software>
    <softwareId>VSYSWASH001-001</softwareId>
    <softwareName>vSys Wash</softwareName>
    <softwareOperation>LOCAL_SOFTWARE</softwareOperation>
    <softwareMainVersion>1.0</softwareMainVersion>
    <softwareDevName>vSys</softwareDevName>
    <softwareDevContact>info@vsys.hu</softwareDevContact>
  </software>
  <transactionId>${transactionId}</transactionId>
</QueryTransactionStatusRequest>`;
  }

  /**
   * Extract transaction ID from response
   */
  private extractTransactionId(responseXml: string): string | null {
    const match = responseXml.match(/<transactionId>([^<]+)<\/transactionId>/);
    return match ? match[1] : null;
  }

  /**
   * Extract error message from response
   */
  private extractErrorMessage(responseXml: string): string | null {
    const match = responseXml.match(/<message>([^<]+)<\/message>/);
    return match ? match[1] : null;
  }

  /**
   * Escape XML special characters
   */
  private escapeXml(text: string): string {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&apos;');
  }
}
